# Ollama Integration Plan - Gabi Family Docs

## ü§ñ **Chatbot IA com Ollama Local - Busca Fluida e Dados Familiares**

### CONTEXT7_QUERY
```yaml
CONTEXT7_QUERY:
  activity: ollama_integration_plan_enhanced
  scope: gabi_family_docs_ai_chatbot_fluent_search
  complexity: alta
  priority: cr√≠tica
  library_ids: [/ollama/ollama, /ollama/ollama-python, /ollama/ollama-js]
  constraints: [local-llm, privacy, document-search, family-data, document-generation]
  output_range: 5000-8000
  agent: bmad_architect
  timestamp: 2025-01-21 19:00:00
  
  QUERY_TEXT: |
    Chatbot Ollama com busca fluida em documentos e dados familiares:
    - Busca inteligente em documentos: "qual o n√∫mero do RG da Sabrina?"
    - Consulta de vencimentos: "quando vence o passaporte da Louise?"
    - Gera√ß√£o de documentos: "crie uma procura√ß√£o da Giovanna para a Louise"
    - Gest√£o de dados familiares: endere√ßos, telefones, informa√ß√µes pessoais
    - Interface conversacional natural e fluida
```

## üéØ **1. VIS√ÉO GERAL DO CHATBOT FLUIDO**

### Objetivo Principal
Criar um **chatbot conversacional fluido** que:
- **Busca em documentos**: Encontra informa√ß√µes espec√≠ficas nos documentos
- **Consulta dados familiares**: Acessa endere√ßos, telefones, informa√ß√µes pessoais
- **Gera documentos**: Cria procura√ß√µes, relat√≥rios, formul√°rios
- **Responde naturalmente**: Interface conversacional como WhatsApp
- **Funciona offline**: Processamento 100% local

### Exemplos de Intera√ß√£o
```
üë§ "Qual o n√∫mero do RG da Sabrina?"
ü§ñ "Encontrei o RG da Sabrina: 12.345.678-9, emitido em 15/03/2010 pela SSP-SP"

üë§ "Quando vence o passaporte brasileiro da Louise?"
ü§ñ "O passaporte da Louise vence em 23/08/2025. Faltam 7 meses para renovar!"

üë§ "Crie uma procura√ß√£o da Giovanna para a Louise"
ü§ñ "Vou criar uma procura√ß√£o. Preciso de algumas informa√ß√µes:
    - Qual o objetivo da procura√ß√£o?
    - Qual o prazo de validade?
    - Precisa ser reconhecida em cart√≥rio?"

üë§ "Qual o endere√ßo da Sabrina?"
ü§ñ "O endere√ßo da Sabrina √©: Rua das Flores, 123, Apto 45, S√£o Paulo-SP, CEP 01234-567"
```

---

## üèóÔ∏è **2. ARQUITETURA AVAN√áADA**

### **Estrutura do Sistema Inteligente**
```
üì± App Mobile (React Native)
    ‚Üì
üí¨ Chat Interface (Fluida)
    ‚Üì
üß† Ollama Service (Local LLM)
    ‚Üì
üìÑ Document Search Engine
    ‚Üì
üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Data Manager
    ‚Üì
üìù Document Generator
    ‚Üì
üîç Vector Database (Embeddings)
```

### **Componentes Principais**

#### **1. Ollama Service Avan√ßado**
```typescript
// services/ollama.ts
import { Ollama } from 'ollama'

export class OllamaService {
  private ollama: Ollama
  private documentSearch: DocumentSearchEngine
  private familyData: FamilyDataManager
  private documentGenerator: DocumentGenerator
  
  constructor() {
    this.ollama = new Ollama({
      host: process.env.EXPO_PUBLIC_OLLAMA_HOST || 'http://localhost:11434'
    })
    this.documentSearch = new DocumentSearchEngine()
    this.familyData = new FamilyDataManager()
    this.documentGenerator = new DocumentGenerator()
  }

  // Chat principal com busca fluida
  async chatWithFamilyData(question: string, context: any) {
    // 1. Analisar a inten√ß√£o da pergunta
    const intent = await this.analyzeIntent(question)
    
    // 2. Buscar dados relevantes
    let relevantData = {}
    
    if (intent.type === 'document_search') {
      relevantData = await this.documentSearch.searchDocuments(
        intent.query, 
        intent.familyMember
      )
    } else if (intent.type === 'family_data') {
      relevantData = await this.familyData.getFamilyMemberData(
        intent.familyMember,
        intent.dataType
      )
    } else if (intent.type === 'document_generation') {
      relevantData = await this.prepareDocumentGeneration(intent)
    }

    // 3. Gerar resposta contextualizada
    const prompt = `
      Voc√™ √© um assistente familiar amig√°vel. Responda de forma natural e √∫til.
      
      Pergunta: ${question}
      Contexto encontrado: ${JSON.stringify(relevantData)}
      Tipo de inten√ß√£o: ${intent.type}
      
      Responda de forma conversacional, como se fosse um WhatsApp.
      Se precisar de mais informa√ß√µes, pergunte de forma natural.
    `
    
    const response = await this.ollama.chat({
      model: 'llama2',
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um assistente familiar que ajuda com documentos e informa√ß√µes da fam√≠lia. Seja amig√°vel e conversacional.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    })
    
    return {
      response: response.message.content,
      intent: intent,
      data: relevantData
    }
  }

  // An√°lise de inten√ß√£o da pergunta
  async analyzeIntent(question: string) {
    const prompt = `
      Analise esta pergunta e identifique:
      1. Tipo de inten√ß√£o: document_search, family_data, document_generation, general_question
      2. Membro da fam√≠lia mencionado (se houver)
      3. Tipo de documento (se aplic√°vel)
      4. Tipo de dado familiar (se aplic√°vel)
      5. Query de busca (se aplic√°vel)
      
      Pergunta: "${question}"
      
      Responda em JSON:
      {
        "type": "document_search|family_data|document_generation|general_question",
        "familyMember": "nome_do_membro",
        "documentType": "rg|passaporte|cpf|etc",
        "dataType": "endereco|telefone|email|etc",
        "query": "termo de busca",
        "confidence": 0.95
      }
    `
    
    const response = await this.ollama.chat({
      model: 'llama2',
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um analisador de inten√ß√µes. Responda apenas em JSON v√°lido.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    })
    
    return JSON.parse(response.message.content)
  }

  // Busca inteligente em documentos
  async searchDocuments(query: string, familyMember: string) {
    return await this.documentSearch.searchDocuments(query, familyMember)
  }

  // Gera√ß√£o de documentos
  async generateDocument(documentType: string, data: any) {
    return await this.documentGenerator.generate(documentType, data)
  }
}
```

#### **2. Document Search Engine**
```typescript
// services/documentSearch.ts
export class DocumentSearchEngine {
  private supabase: any
  private vectorDB: any

  constructor() {
    this.supabase = createClient(/* config */)
    this.vectorDB = new VectorDatabase()
  }

  // Busca inteligente em documentos
  async searchDocuments(query: string, familyMember?: string) {
    try {
      // 1. Busca por texto completo
      const textResults = await this.searchByText(query, familyMember)
      
      // 2. Busca por embeddings (sem√¢ntica)
      const semanticResults = await this.searchBySemantics(query, familyMember)
      
      // 3. Busca por metadados
      const metadataResults = await this.searchByMetadata(query, familyMember)
      
      // 4. Combinar e rankear resultados
      const combinedResults = this.combineAndRankResults(
        textResults, 
        semanticResults, 
        metadataResults
      )
      
      return {
        query,
        familyMember,
        results: combinedResults,
        totalFound: combinedResults.length
      }
    } catch (error) {
      console.error('Erro na busca:', error)
      throw error
    }
  }

  // Busca por texto completo
  private async searchByText(query: string, familyMember?: string) {
    let searchQuery = this.supabase
      .from('documents')
      .select('*')
      .textSearch('content', query)
    
    if (familyMember) {
      searchQuery = searchQuery.eq('family_member', familyMember)
    }
    
    const { data, error } = await searchQuery
    return data || []
  }

  // Busca sem√¢ntica por embeddings
  private async searchBySemantics(query: string, familyMember?: string) {
    // Implementar busca por similaridade sem√¢ntica
    // usando embeddings do Ollama
    return []
  }

  // Busca por metadados
  private async searchByMetadata(query: string, familyMember?: string) {
    const { data, error } = await this.supabase
      .from('documents')
      .select('*')
      .or(`title.ilike.%${query}%,tags.cs.{${query}}`)
    
    return data || []
  }

  // Combinar e rankear resultados
  private combineAndRankResults(textResults: any[], semanticResults: any[], metadataResults: any[]) {
    // Algoritmo de ranking personalizado
    const allResults = [...textResults, ...semanticResults, ...metadataResults]
    
    // Remover duplicatas
    const uniqueResults = this.removeDuplicates(allResults)
    
    // Aplicar scoring
    const scoredResults = uniqueResults.map(result => ({
      ...result,
      score: this.calculateRelevanceScore(result)
    }))
    
    // Ordenar por relev√¢ncia
    return scoredResults.sort((a, b) => b.score - a.score)
  }

  private calculateRelevanceScore(result: any): number {
    let score = 0
    
    // Score baseado no tipo de match
    if (result.matchType === 'exact') score += 10
    if (result.matchType === 'partial') score += 5
    if (result.matchType === 'semantic') score += 3
    
    // Score baseado na data (documentos mais recentes)
    const daysSinceCreation = (Date.now() - new Date(result.created_at).getTime()) / (1000 * 60 * 60 * 24)
    score += Math.max(0, 10 - daysSinceCreation / 30)
    
    return score
  }
}
```

#### **3. Family Data Manager**
```typescript
// services/familyData.ts
export class FamilyDataManager {
  private supabase: any

  constructor() {
    this.supabase = createClient(/* config */)
  }

  // Buscar dados de um membro da fam√≠lia
  async getFamilyMemberData(familyMember: string, dataType?: string) {
    try {
      let query = this.supabase
        .from('family_members')
        .select('*')
        .ilike('name', `%${familyMember}%`)
      
      if (dataType) {
        query = query.select(`id, name, ${dataType}`)
      }
      
      const { data, error } = await query
      
      if (error) throw error
      
      return {
        familyMember,
        dataType,
        results: data || [],
        found: data?.length > 0
      }
    } catch (error) {
      console.error('Erro ao buscar dados familiares:', error)
      throw error
    }
  }

  // Buscar endere√ßo
  async getAddress(familyMember: string) {
    const result = await this.getFamilyMemberData(familyMember, 'address')
    return result.results[0]?.address || null
  }

  // Buscar telefone
  async getPhone(familyMember: string) {
    const result = await this.getFamilyMemberData(familyMember, 'phone')
    return result.results[0]?.phone || null
  }

  // Buscar email
  async getEmail(familyMember: string) {
    const result = await this.getFamilyMemberData(familyMember, 'email')
    return result.results[0]?.email || null
  }

  // Buscar documentos
  async getDocuments(familyMember: string) {
    const { data, error } = await this.supabase
      .from('documents')
      .select('*')
      .eq('family_member', familyMember)
    
    if (error) throw error
    
    return data || []
  }

  // Atualizar dados
  async updateFamilyMemberData(familyMember: string, data: any) {
    const { data: result, error } = await this.supabase
      .from('family_members')
      .update(data)
      .eq('name', familyMember)
    
    if (error) throw error
    
    return result
  }
}
```

#### **4. Document Generator**
```typescript
// services/documentGenerator.ts
export class DocumentGenerator {
  private ollama: OllamaService

  constructor() {
    this.ollama = new OllamaService()
  }

  // Gerar documento
  async generateDocument(documentType: string, data: any) {
    try {
      const template = await this.getTemplate(documentType)
      const filledTemplate = await this.fillTemplate(template, data)
      
      return {
        type: documentType,
        content: filledTemplate,
        generated_at: new Date().toISOString(),
        data_used: data
      }
    } catch (error) {
      console.error('Erro na gera√ß√£o de documento:', error)
      throw error
    }
  }

  // Gerar procura√ß√£o
  async generatePowerOfAttorney(fromPerson: string, toPerson: string, purpose: string) {
    const data = {
      from_person: fromPerson,
      to_person: toPerson,
      purpose: purpose,
      date: new Date().toLocaleDateString('pt-BR'),
      template_type: 'power_of_attorney'
    }
    
    return await this.generateDocument('power_of_attorney', data)
  }

  // Preencher template
  private async fillTemplate(template: string, data: any) {
    const prompt = `
      Preencha este template com os dados fornecidos:
      
      Template:
      ${template}
      
      Dados:
      ${JSON.stringify(data, null, 2)}
      
      Retorne apenas o documento preenchido, sem explica√ß√µes adicionais.
    `
    
    const response = await this.ollama.chat({
      model: 'llama2',
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um especialista em documentos legais. Preencha templates de forma precisa e profissional.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    })
    
    return response.message.content
  }

  // Obter template
  private async getTemplate(documentType: string): Promise<string> {
    const templates = {
      power_of_attorney: `
        PROCURA√á√ÉO

        Eu, {{from_person}}, brasileiro(a), portador(a) do RG n¬∫ ________ e CPF n¬∫ ________, residente e domiciliado(a) em ________, nomeio e constituo como meu bastante procurador(a) {{to_person}}, brasileiro(a), portador(a) do RG n¬∫ ________ e CPF n¬∫ ________, residente e domiciliado(a) em ________, para que em meu nome e √† minha conta possa:

        {{purpose}}

        Outorga poderes para substabelecer, no todo ou em parte, a presente procura√ß√£o.

        Local e data: ________, {{date}}

        _________________________________
        {{from_person}}
        Outorgante
      `,
      
      // Adicionar mais templates conforme necess√°rio
    }
    
    return templates[documentType] || 'Template n√£o encontrado'
  }
}
```

---

## üé® **3. INTERFACE FLUIDA DO CHAT**

### **Chat Interface Melhorada**
```typescript
// components/ai/FluentChat.tsx
import React, { useState, useRef, useEffect } from 'react'
import { View, Text, TextInput, TouchableOpacity, ScrollView, KeyboardAvoidingView, Platform } from 'react-native'
import { OllamaService } from '../../services/ollama'

interface Message {
  id: string
  text: string
  isUser: boolean
  timestamp: Date
  intent?: any
  data?: any
  isLoading?: boolean
}

export const FluentChat: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([])
  const [inputText, setInputText] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const ollamaService = new OllamaService()
  const scrollViewRef = useRef<ScrollView>(null)

  // Mensagem de boas-vindas
  useEffect(() => {
    const welcomeMessage: Message = {
      id: 'welcome',
      text: 'Ol√°! Sou seu assistente familiar. Posso ajudar com:\n\nüìÑ Buscar documentos\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Informa√ß√µes da fam√≠lia\nüìù Gerar documentos\n‚è∞ Lembretes de vencimento\n\nComo posso ajudar?',
      isUser: false,
      timestamp: new Date()
    }
    setMessages([welcomeMessage])
  }, [])

  const sendMessage = async () => {
    if (!inputText.trim()) return

    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputText,
      isUser: true,
      timestamp: new Date()
    }

    setMessages(prev => [...prev, userMessage])
    setInputText('')
    setIsTyping(true)

    // Adicionar mensagem de "digitando..."
    const typingMessage: Message = {
      id: 'typing',
      text: 'ü§î Pensando...',
      isUser: false,
      timestamp: new Date(),
      isLoading: true
    }
    setMessages(prev => [...prev, typingMessage])

    try {
      // Buscar contexto da fam√≠lia
      const familyContext = await getFamilyContext()
      
      // Processar com Ollama
      const result = await ollamaService.chatWithFamilyData(
        inputText, 
        familyContext
      )

      // Remover mensagem de "digitando..."
      setMessages(prev => prev.filter(msg => msg.id !== 'typing'))

      // Adicionar resposta
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: result.response,
        isUser: false,
        timestamp: new Date(),
        intent: result.intent,
        data: result.data
      }

      setMessages(prev => [...prev, aiMessage])

      // Se for gera√ß√£o de documento, mostrar op√ß√µes
      if (result.intent.type === 'document_generation') {
        await showDocumentOptions(result.intent, result.data)
      }

    } catch (error) {
      console.error('Erro no chat:', error)
      
      // Remover mensagem de "digitando..."
      setMessages(prev => prev.filter(msg => msg.id !== 'typing'))
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: 'Desculpe, n√£o consegui processar sua pergunta. Pode reformular?',
        isUser: false,
        timestamp: new Date()
      }
      setMessages(prev => [...prev, errorMessage])
    } finally {
      setIsTyping(false)
    }
  }

  // Mostrar op√ß√µes para gera√ß√£o de documentos
  const showDocumentOptions = async (intent: any, data: any) => {
    const optionsMessage: Message = {
      id: 'options',
      text: 'Preciso de mais algumas informa√ß√µes para gerar o documento. Pode me ajudar?',
      isUser: false,
      timestamp: new Date()
    }
    
    setMessages(prev => [...prev, optionsMessage])
    
    // Adicionar bot√µes de op√ß√µes r√°pidas
    const quickOptions = generateQuickOptions(intent, data)
    // Implementar interface de bot√µes
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        ref={scrollViewRef}
        style={styles.messagesContainer}
        onContentSizeChange={() => scrollViewRef.current?.scrollToEnd()}
      >
        {messages.map(message => (
          <View 
            key={message.id} 
            style={[
              styles.messageBubble,
              message.isUser ? styles.userMessage : styles.aiMessage
            ]}
          >
            <Text style={styles.messageText}>{message.text}</Text>
            <Text style={styles.timestamp}>
              {message.timestamp.toLocaleTimeString()}
            </Text>
            
            {/* Mostrar dados encontrados */}
            {message.data && message.data.results && (
              <View style={styles.dataPreview}>
                <Text style={styles.dataTitle}>üìÑ Documentos encontrados:</Text>
                {message.data.results.slice(0, 3).map((result: any, index: number) => (
                  <Text key={index} style={styles.dataItem}>
                    ‚Ä¢ {result.title} ({result.document_type})
                  </Text>
                ))}
              </View>
            )}
          </View>
        ))}
      </ScrollView>

      <View style={styles.inputContainer}>
        <TextInput
          style={styles.textInput}
          value={inputText}
          onChangeText={setInputText}
          placeholder="Pergunte sobre documentos, endere√ßos, telefones..."
          multiline
          maxLength={500}
        />
        <TouchableOpacity 
          style={[styles.sendButton, !inputText.trim() && styles.sendButtonDisabled]}
          onPress={sendMessage}
          disabled={!inputText.trim() || isTyping}
        >
          <Text style={styles.sendButtonText}>
            {isTyping ? '‚è≥' : 'üì§'}
          </Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  )
}
```

---

## üìä **4. BASE DE DADOS FAMILIARES**

### **Schema do Banco de Dados**
```sql
-- Tabela de membros da fam√≠lia
CREATE TABLE family_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255),
  phone VARCHAR(20),
  address TEXT,
  birth_date DATE,
  cpf VARCHAR(14),
  rg VARCHAR(20),
  passport VARCHAR(20),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Tabela de documentos
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_member_id UUID REFERENCES family_members(id),
  title VARCHAR(255) NOT NULL,
  content TEXT,
  document_type VARCHAR(50),
  file_path VARCHAR(500),
  tags TEXT[],
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Tabela de dados pessoais
CREATE TABLE personal_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_member_id UUID REFERENCES family_members(id),
  data_type VARCHAR(50) NOT NULL, -- 'address', 'phone', 'email', 'document_number'
  data_key VARCHAR(100) NOT NULL, -- 'home_address', 'work_phone', 'rg_number'
  data_value TEXT NOT NULL,
  is_primary BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- √çndices para busca r√°pida
CREATE INDEX idx_documents_family_member ON documents(family_member_id);
CREATE INDEX idx_documents_content ON documents USING gin(to_tsvector('portuguese', content));
CREATE INDEX idx_personal_data_member_type ON personal_data(family_member_id, data_type);
```

---

## üîç **5. FUNCIONALIDADES DE BUSCA**

### **Tipos de Busca Implementados**

#### **1. Busca por Documento Espec√≠fico**
```
üë§ "Qual o n√∫mero do RG da Sabrina?"
ü§ñ "Encontrei o RG da Sabrina: 12.345.678-9, emitido em 15/03/2010 pela SSP-SP"
```

#### **2. Busca por Vencimento**
```
üë§ "Quando vence o passaporte da Louise?"
ü§ñ "O passaporte da Louise vence em 23/08/2025. Faltam 7 meses para renovar!"
```

#### **3. Busca por Informa√ß√µes Pessoais**
```
üë§ "Qual o endere√ßo da Sabrina?"
ü§ñ "O endere√ßo da Sabrina √©: Rua das Flores, 123, Apto 45, S√£o Paulo-SP, CEP 01234-567"
```

#### **4. Gera√ß√£o de Documentos**
```
üë§ "Crie uma procura√ß√£o da Giovanna para a Louise"
ü§ñ "Vou criar uma procura√ß√£o. Preciso de algumas informa√ß√µes:
    - Qual o objetivo da procura√ß√£o?
    - Qual o prazo de validade?
    - Precisa ser reconhecida em cart√≥rio?"
```

---

## üìù **6. GERA√á√ÉO DE DOCUMENTOS**

### **Templates Dispon√≠veis**
- **Procura√ß√£o**: Procura√ß√£o geral ou espec√≠fica
- **Declara√ß√£o**: Declara√ß√µes simples
- **Relat√≥rio**: Relat√≥rios de documentos
- **Lista**: Listas de documentos por categoria
- **Lembrete**: Lembretes de vencimento

### **Processo de Gera√ß√£o**
1. **An√°lise da Solicita√ß√£o**: Ollama identifica o tipo de documento
2. **Coleta de Dados**: Busca informa√ß√µes necess√°rias
3. **Sele√ß√£o de Template**: Escolhe template apropriado
4. **Preenchimento**: Preenche com dados reais
5. **Revis√£o**: Verifica consist√™ncia
6. **Entrega**: Retorna documento pronto

---

## üéØ **7. PR√ìXIMOS PASSOS**

### **Imediatos**
1. üîÑ **Implementar Document Search Engine**
2. üîÑ **Criar Family Data Manager**
3. üîÑ **Desenvolver Document Generator**
4. üîÑ **Interface fluida do chat**

### **Curto Prazo**
1. üîÑ **Templates de documentos**
2. üîÑ **Busca sem√¢ntica avan√ßada**
3. üîÑ **Integra√ß√£o com Supabase**
4. üîÑ **Testes de usabilidade**

### **M√©dio Prazo**
1. üîÑ **Otimiza√ß√µes de performance**
2. üîÑ **Mais tipos de documentos**
3. üîÑ **Busca por voz**
4. üîÑ **Notifica√ß√µes inteligentes**

---

## üéâ **8. CONCLUS√ÉO**

O **Chatbot Fluido Ollama** oferece:

‚úÖ **Busca Inteligente**: Encontra informa√ß√µes espec√≠ficas em documentos
‚úÖ **Dados Familiares**: Gerencia endere√ßos, telefones, informa√ß√µes pessoais
‚úÖ **Gera√ß√£o de Documentos**: Cria procura√ß√µes, relat√≥rios, formul√°rios
‚úÖ **Interface Natural**: Conversa√ß√£o fluida como WhatsApp
‚úÖ **Processamento Local**: 100% privado e seguro
‚úÖ **Contexto Familiar**: Entende relacionamentos e necessidades da fam√≠lia

**Status**: üöÄ **PRONTO PARA IMPLEMENTA√á√ÉO AVAN√áADA**

---

**Respons√°vel**: BMad Architect + Context7
**Data**: 2025-01-21
**Vers√£o**: 2.0.0
**Status**: ‚úÖ Aprovado para desenvolvimento avan√ßado
